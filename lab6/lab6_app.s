; Generated by c86 (BYU-NASM) 5.1 (beta) from lab6_app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
L_lab6_app_5:
	DB	"Max: ",0
L_lab6_app_4:
	DB	"Min: ",0
L_lab6_app_3:
	DB	0x9,0
L_lab6_app_2:
	DB	"Ticks: ",0
L_lab6_app_1:
	DB	"! Dropped msgs: tick ",0
	ALIGN	2
ATask:
	; >>>>> Line:	26
	; >>>>> { 
	jmp	L_lab6_app_6
L_lab6_app_7:
	; >>>>> Line:	30
	; >>>>> min = 100; 
	mov	word [bp-4], 100
	; >>>>> Line:	31
	; >>>>> max = 0; 
	mov	word [bp-6], 0
	; >>>>> Line:	32
	; >>>>> count = 0; 
	mov	word [bp-8], 0
	; >>>>> Line:	34
	; >>>>> while (1) 
	jmp	L_lab6_app_9
L_lab6_app_8:
	; >>>>> Line:	36
	; >>>>> tmp = (struct msg *) YKQPend(MsgQPtr); 
	push	word [MsgQPtr]
	call	YKQPend
	add	sp, 2
	mov	word [bp-2], ax
	; >>>>> Line:	44
	; >>>>> if (tmp->tick != count+1) 
	mov	ax, word [bp-8]
	inc	ax
	mov	si, word [bp-2]
	mov	dx, word [si]
	cmp	dx, ax
	je	L_lab6_app_11
	; >>>>> Line:	46
	; >>>>> print("! Dropped msgs: tick ", 21); 
	mov	ax, 21
	push	ax
	mov	ax, L_lab6_app_1
	push	ax
	call	print
	add	sp, 4
	; >>>>> Line:	47
	; >>>>> if (tmp->tick - (count+1) > 1) { 
	mov	si, word [bp-2]
	mov	ax, word [si]
	sub	ax, word [bp-8]
	dec	ax
	cmp	ax, 1
	jle	L_lab6_app_12
	; >>>>> Line:	48
	; >>>>> printInt(count+1); 
	mov	ax, word [bp-8]
	inc	ax
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	49
	; >>>>> printChar('-'); 
	mov	al, 45
	push	ax
	call	printChar
	add	sp, 2
	; >>>>> Line:	50
	; >>>>> printInt(tmp->tick-1); 
	mov	si, word [bp-2]
	mov	ax, word [si]
	dec	ax
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	51
	; >>>>> printNe 
	call	printNewLine
	jmp	L_lab6_app_13
L_lab6_app_12:
	; >>>>> Line:	54
	; >>>>> printInt(tmp->tick-1); 
	mov	si, word [bp-2]
	mov	ax, word [si]
	dec	ax
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	55
	; >>>>> printNewLine(); 
	call	printNewLine
L_lab6_app_13:
L_lab6_app_11:
	; >>>>> Line:	60
	; >>>>> count = tmp->tick; 
	mov	si, word [bp-2]
	mov	ax, word [si]
	mov	word [bp-8], ax
	; >>>>> Line:	63
	; >>>>> if (tmp->data < min) 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [bp-4]
	cmp	ax, word [si]
	jle	L_lab6_app_14
	; >>>>> Line:	64
	; >>>>> min = tmp->data; 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-4], ax
L_lab6_app_14:
	; >>>>> Line:	65
	; >>>>> if (tmp->data > max) 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [bp-6]
	cmp	ax, word [si]
	jge	L_lab6_app_15
	; >>>>> Line:	66
	; >>>>> max = tmp->data; 
	mov	si, word [bp-2]
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-6], ax
L_lab6_app_15:
	; >>>>> Line:	69
	; >>>>> print("Ticks: ", 7); 
	mov	ax, 7
	push	ax
	mov	ax, L_lab6_app_2
	push	ax
	call	print
	add	sp, 4
	; >>>>> Line:	70
	; >>>>> printInt(count); 
	push	word [bp-8]
	call	printInt
	add	sp, 2
	; >>>>> Line:	71
	; >>>>> print("\t", 1); 
	mov	ax, 1
	push	ax
	mov	ax, L_lab6_app_3
	push	ax
	call	print
	add	sp, 4
	; >>>>> Line:	72
	; >>>>> print("Min: ", 5); 
	mov	ax, 5
	push	ax
	mov	ax, L_lab6_app_4
	push	ax
	call	print
	add	sp, 4
	; >>>>> Line:	73
	; >>>>> printInt(min); 
	push	word [bp-4]
	call	printInt
	add	sp, 2
	; >>>>> Line:	74
	; >>>>> print("\t", 1); 
	mov	ax, 1
	push	ax
	mov	ax, L_lab6_app_3
	push	ax
	call	print
	add	sp, 4
	; >>>>> Line:	75
	; >>>>> print("Max: ", 5); 
	mov	ax, 5
	push	ax
	mov	ax, L_lab6_app_5
	push	ax
	call	print
	add	sp, 4
	; >>>>> Line:	76
	; >>>>> printInt(max); 
	push	word [bp-6]
	call	printInt
	add	sp, 2
	; >>>>> Line:	77
	; >>>>> nt + 5) break; 
	call	printNewLine
L_lab6_app_9:
	jmp	L_lab6_app_8
L_lab6_app_10:
	mov	sp, bp
	pop	bp
	ret
L_lab6_app_6:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab6_app_7
	ALIGN	2
BTask:
	; >>>>> Line:	82
	; >>>>> { 
	jmp	L_lab6_app_17
L_lab6_app_18:
	; >>>>> Line:	86
	; >>>>> curval = 1001; 
	mov	word [bp-4], 1001
	; >>>>> Line:	87
	; >>>>> chcount = 0; 
	mov	word [bp-10], 0
	; >>>>> Line:	89
	; >>>>> while (1) 
	jmp	L_lab6_app_20
L_lab6_app_19:
	; >>>>> Line:	91
	; >>>>> YKDelayTask(2); 
	mov	ax, 2
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	93
	; >>>>> if (GlobalFlag == 1) 
	cmp	word [GlobalFlag], 1
	jne	L_lab6_app_22
	; >>>>> Line:	95
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	96
	; >>>>> busycount = YKTickNum; 
	mov	ax, word [YKTickNum]
	mov	word [bp-2], ax
	; >>>>> Line:	97
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	99
	; >>>>> while (1) 
	jmp	L_lab6_app_24
L_lab6_app_23:
	; >>>>> Line:	101
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	102
	; >>>>> tickNum = YKTickNum; 
	mov	ax, word [YKTickNum]
	mov	word [bp-12], ax
	; >>>>> Line:	103
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	104
	; >>>>> if(tickNum >= busycount + 5) break; 
	mov	ax, word [bp-2]
	add	ax, 5
	mov	dx, word [bp-12]
	cmp	dx, ax
	jb	L_lab6_app_26
	; >>>>> Line:	104
	; >>>>> if(tickNum >= busycount + 5) break; 
	jmp	L_lab6_app_25
L_lab6_app_26:
	; >>>>> Line:	106
	; >>>>>  
	add	word [bp-4], 2
	; >>>>> Line:	107
	; >>>>> flag = 0; 
	mov	word [bp-8], 0
	; >>>>> Line:	108
	; >>>>> for (j = 3; (j*j) < curval; j += 2) 
	mov	word [bp-6], 3
	jmp	L_lab6_app_28
L_lab6_app_27:
	; >>>>> Line:	110
	; >>>>> if (curval % j == 0) 
	mov	ax, word [bp-4]
	cwd
	idiv	word [bp-6]
	mov	ax, dx
	test	ax, ax
	jne	L_lab6_app_31
	; >>>>> Line:	112
	; >>>>> flag = 1; 
	mov	word [bp-8], 1
	; >>>>> Line:	113
	; >>>>> break; 
	jmp	L_lab6_app_29
L_lab6_app_31:
L_lab6_app_30:
	add	word [bp-6], 2
L_lab6_app_28:
	mov	ax, word [bp-6]
	imul	word [bp-6]
	mov	dx, word [bp-4]
	cmp	dx, ax
	jg	L_lab6_app_27
L_lab6_app_29:
	; >>>>> Line:	116
	; >>>>> if (!flag) 
	mov	ax, word [bp-8]
	test	ax, ax
	jne	L_lab6_app_32
	; >>>>> Line:	118
	; >>>>> printChar('.'); 
	mov	al, 46
	push	ax
	call	printChar
	add	sp, 2
	; >>>>> Line:	119
	; >>>>> if (++chcount > 75) 
	mov	ax, word [bp-10]
	inc	ax
	mov	word [bp-10], ax
	cmp	ax, 75
	jle	L_lab6_app_33
	; >>>>> Line:	121
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	122
	; >>>>> chcount = 0; 
	mov	word [bp-10], 0
L_lab6_app_33:
L_lab6_app_32:
L_lab6_app_24:
	jmp	L_lab6_app_23
L_lab6_app_25:
	; >>>>> Line:	126
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	127
	; >>>>> chcount = 0; 
	mov	word [bp-10], 0
	; >>>>> Line:	128
	; >>>>> GlobalFlag = 0; 
	mov	word [GlobalFlag], 0
L_lab6_app_22:
L_lab6_app_20:
	jmp	L_lab6_app_19
L_lab6_app_21:
	mov	sp, bp
	pop	bp
	ret
L_lab6_app_17:
	push	bp
	mov	bp, sp
	sub	sp, 12
	jmp	L_lab6_app_18
L_lab6_app_39:
	DB	"% >>>>>",0xD,0xA,0
L_lab6_app_38:
	DB	", CPU usage: ",0
L_lab6_app_37:
	DB	"<<<<< Context switches: ",0
L_lab6_app_36:
	DB	"Determining CPU capacity",0xD,0xA,0
L_lab6_app_35:
	DB	"Welcome to the YAK kernel",0xD,0xA,0
	ALIGN	2
STask:
	; >>>>> Line:	134
	; >>>>> { 
	jmp	L_lab6_app_40
L_lab6_app_41:
	; >>>>> Line:	138
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	139
	; >>>>> printString("Welcome to the YAK kernel\r\n"); 
	mov	ax, L_lab6_app_35
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	140
	; >>>>> printString("Determining CPU capacity\r\n"); 
	mov	ax, L_lab6_app_36
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	141
	; >>>>> YKDelayTask(1); 
	mov	ax, 1
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	142
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	143
	; >>>>> YKDelayTask(5); 
	mov	ax, 5
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	144
	; >>>>> max = YKIdleCount / 25; 
	mov	ax, word [YKIdleCount]
	xor	dx, dx
	mov	cx, 25
	div	cx
	mov	word [bp-2], ax
	; >>>>> Line:	145
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	147
	; >>>>> YKNewTask(BTask, (void *) &BTaskStk[512], 10); 
	mov	al, 10
	push	ax
	mov	ax, (BTaskStk+1024)
	push	ax
	mov	ax, BTask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	148
	; >>>>> = 0; 
	mov	al, 20
	push	ax
	mov	ax, (ATaskStk+1024)
	push	ax
	mov	ax, ATask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	150
	; >>>>> while (1) 
	jmp	L_lab6_app_43
L_lab6_app_42:
	; >>>>> Line:	152
	; >>>>> YKDelayTask(20); 
	mov	ax, 20
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	154
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	155
	; >>>>> switchCount = YKCtxSwCount; 
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	; >>>>> Line:	156
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-6], ax
	; >>>>> Line:	157
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	159
	; >>>>> printString("<<<<< Context switches: "); 
	mov	ax, L_lab6_app_37
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	160
	; >>>>> printInt((int)switchCount); 
	push	word [bp-4]
	call	printInt
	add	sp, 2
	; >>>>> Line:	161
	; >>>>> printString(", CPU usage: "); 
	mov	ax, L_lab6_app_38
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	162
	; >>>>> tmp = (int) (idleCount/max); 
	mov	ax, word [bp-6]
	xor	dx, dx
	div	word [bp-2]
	mov	word [bp-8], ax
	; >>>>> Line:	163
	; >>>>> printInt(100-tmp); 
	mov	ax, 100
	sub	ax, word [bp-8]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	164
	; >>>>> printString("% >>>>>\r\n"); 
	mov	ax, L_lab6_app_39
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	166
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	167
	; >>>>> YKCtxSwCount = 0; 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	168
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	169
	; >>>>>  
	call	YKExitMutex
L_lab6_app_43:
	jmp	L_lab6_app_42
L_lab6_app_44:
	mov	sp, bp
	pop	bp
	ret
L_lab6_app_40:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_lab6_app_41
	ALIGN	2
main:
	; >>>>> Line:	174
	; >>>>> { 
	jmp	L_lab6_app_46
L_lab6_app_47:
	; >>>>> Line:	175
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	178
	; >>>>> GlobalFlag = 0; 
	mov	word [GlobalFlag], 0
	; >>>>> Line:	179
	; >>>>> MsgQPtr = YKQCreate(MsgQ, 10); 
	mov	ax, 10
	push	ax
	mov	ax, MsgQ
	push	ax
	call	YKQCreate
	add	sp, 4
	mov	word [MsgQPtr], ax
	; >>>>> Line:	180
	; >>>>> YKNewTask(STask, (void *) &STaskStk[512], 30); 
	mov	al, 30
	push	ax
	mov	ax, (STaskStk+1024)
	push	ax
	mov	ax, STask
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	183
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab6_app_46:
	push	bp
	mov	bp, sp
	jmp	L_lab6_app_47
	ALIGN	2
MsgArray:
	TIMES	80 db 0
ATaskStk:
	TIMES	1024 db 0
BTaskStk:
	TIMES	1024 db 0
STaskStk:
	TIMES	1024 db 0
GlobalFlag:
	TIMES	2 db 0
MsgQ:
	TIMES	20 db 0
MsgQPtr:
	TIMES	2 db 0
