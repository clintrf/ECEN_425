        CPU     8086
        ORG     0h
InterruptVectorTable:
        ; Internal x86 Interrupts:
        dd      0 ; Reserved (Div err)  ; Int 00h
        dd      0 ; Reserved (Step)     ; Int 01h
        dd      0 ; Reserved (NMI)      ; Int 02h
        dd      0 ; Reserved (Break)    ; Int 03h
        dd      0 ; Reserved (Overflow) ; Int 04h
        dd      0                       ; Int 05h
        dd      0                       ; Int 06h
        dd      0                       ; Int 07h
        ; Hardware Interrupts:
        dd      RESET ; Reset               ; Int 08h (IRQ 0)
        dd      TICK ; Tick                ; Int 09h (IRQ 1)
        dd      KEY ; Keyboard            ; Int 0Ah (IRQ 2)
        dd      0 ; Simptris Game Over  ; Int 0Bh (IRQ 3)
        dd      0 ; Simptris New Piece  ; Int 0Ch (IRQ 4)
        dd      0 ; Simptris Received   ; Int 0Dh (IRQ 5)
        dd      0 ; Simptris Touchdown  ; Int 0Eh (IRQ 6)
        dd      0 ; Simptris Clear      ; Int 0Fh (IRQ 7)
        ; Software Interrupts:
        dd      0 ; Reserved (PC BIOS)  ; Int 10h
        dd      0                       ; Int 11h
        dd      0                       ; Int 12h
        dd      0                       ; Int 13h
        dd      0                       ; Int 14h
        dd      0                       ; Int 15h
        dd      0                       ; Int 16h
        dd      0                       ; Int 17h
        dd      0                       ; Int 18h
        dd      0                       ; Int 19h
        dd      0                       ; Int 1Ah
        dd      0                       ; Int 1Bh
        dd      0                       ; Int 1Ch
        dd      0                       ; Int 1Dh
        dd      0                       ; Int 1Eh
        dd      0                       ; Int 1Fh
        dd      0                       ; Int 20h
        dd      0 ; Reserved (DOS)      ; Int 21h
        dd      0 ; Simptris Services   ; Int 22h
        dd      0                       ; Int 23h
        dd      0                       ; Int 24h
        dd      0                       ; Int 25h
        dd      0                       ; Int 26h
        dd      0                       ; Int 27h
        dd      0                       ; Int 28h
        dd      0                       ; Int 29h
        dd      0                       ; Int 2Ah
        dd      0                       ; Int 2Bh
        dd      0                       ; Int 2Ch
        dd      0                       ; Int 2Dh
        dd      0                       ; Int 2Eh
        dd      0                       ; Int 2Fh
KeyBuffer:                              ; Address 0xC0
        dw      0
NewPieceType:                           ; Address 0xC2
        dw      0
NewPieceID:                             ; Address 0xC4
        dw      0
NewPieceOrientation:                    ; Address 0xC6
        dw      0
NewPieceColumn:                         ; Address 0xC8
        dw      0
TouchdownID:                            ; Address 0xCA
	dw	0
ScreenBitMap0:                          ; Address 0xCC
        dw      0
ScreenBitMap1:
        dw      0
ScreenBitMap2:
        dw      0
ScreenBitMap3:
        dw      0
ScreenBitMap4:
        dw      0
ScreenBitMap5:
        dw      0
TIMES   100h-($-$$) db  0               ; Fill up to (but not including) address 100h with 0
	jmp	main
; This file contains support routines for 32-bit on the 8086.
; It is intended for use code generated by the C86 compiler.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SR_asldiv:			; l1 /= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_ldiv
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslmod:			; l1 %= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lmod
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslmul:			; l1 *= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lmul
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslshl:			; l1 <<= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lshl
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_aslshr:			; l1 >>= l2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of l1	(was push3)
	push	word [bp+8]	; Push hi l2		(was push1)
	push	word [bp+6]	; Push lo l2		(was push2)
	push	word [bx+2]	; Push hi l1
	push	word [bx]	; Push lo l1
	call	SR_lshr
	add	sp,8
	mov	bx,[bp+4]	; Restore l1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret


SR_asuldiv:			; u1 /= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_uldiv
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asilmod:			; u1 %= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ilmod
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulmul:			; u1 *= u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulmul
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulshl:			; u1 << u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulshl
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret
SR_asulshr:			; u1 >> u2
	push	bp
	mov	bp,sp
	push	bx
	mov	bx,[bp+4]	; Get address of u1	(was push3)
	push	word [bp+8]	; Push hi u2		(was push1)
	push	word [bp+6]	; Push lo u2		(was push2)
	push	word [bx+2]	; Push hi u1
	push	word [bx]	; Push lo u1
	call	SR_ulshr
	add	sp,8
	mov	bx,[bp+4]	; Restore u1 address
	mov	[bx+2],dx	; Store result
	mov	[bx],ax
	pop	bx
	pop	bp
	ret


; Main 32-bit routines begin here:

SR_ldiv:	; N_LDIV@
	pop    cx
	push   cs
	push   cx
	; LDIV@
	xor    cx,cx
	jmp    LSR_01
SR_uldiv:	; N_LUDIV@
	pop    cx
	push   cs
	push   cx
	; F_LUDIV@
	mov    cx,0001
	jmp    LSR_01
SR_lmod:	; N_LMOD@
	pop    cx
	push   cs
	push   cx
	; F_LMOD@
	mov    cx,0002
	jmp    LSR_01
SR_ilmod:	; N_LUMOD@
	pop    cx
	push   cs
	push   cx
	; LUMOD@
	mov    cx,0003
LSR_01:
	push   bp
	push   si
	push   di
	mov    bp,sp
	mov    di,cx
	mov    ax,[bp+0Ah]
	mov    dx,[bp+0Ch]
	mov    bx,[bp+0Eh]
	mov    cx,[bp+10h]
	or     cx,cx
	jne    LSR_02
	or     dx,dx
	je     LSR_10
	or     bx,bx
	je     LSR_10
LSR_02:
	test   di,0001
	jne    LSR_04
	or     dx,dx
	jns    LSR_03
	neg    dx
	neg    ax
	sbb    dx,0000
	or     di,000Ch
LSR_03:
	or     cx,cx
	jns    LSR_04
	neg    cx
	neg    bx
	sbb    cx,0000
	xor    di,0004
LSR_04:
	mov    bp,cx
	mov    cx,0020h
	push   di
	xor    di,di
	xor    si,si
LSR_05:
	shl    ax,1
	rcl    dx,1
	rcl    si,1
	rcl    di,1
	cmp    di,bp
	jb     LSR_07
	ja     LSR_06
	cmp    si,bx
	jb     LSR_07
LSR_06:
	sub    si,bx
	sbb    di,bp
	inc    ax
LSR_07:
	loop   LSR_05
	pop    bx
	test   bx,0002
	je     LSR_08
	mov    ax,si
	mov    dx,di
	shr    bx,1
LSR_08:
	test   bx,0004h
	je     LSR_09
	neg    dx
	neg    ax
	sbb    dx,0000
LSR_09:
	pop    di
	pop    si
	pop    bp
	retf   0008
LSR_10:
	div    bx
	test   di,0002
	je     LSR_11
	xchg   dx,ax
LSR_11:
	xor    dx,dx
	jmp    LSR_09
SR_lshl:	; N_LXLSH@
SR_ulshl:
	; r = a << b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

	mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)
	
	; LXLSH@
	cmp    cl,10h
	jnb    LSR_12
	mov    bx,ax
	shl    ax,cl
	shl    dx,cl
	neg    cl
	add    cl,10h
	shr    bx,cl
	or     dx,bx
	pop    cx
	pop    bp
	retf
LSR_12:
	sub    cl,10h
	xchg   dx,ax
	xor    ax,ax
	shl    dx,cl
	pop    cx
	pop    bp
	retf
SR_lshr:	; N_LXRSH@
	; r = a >> b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

        mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)
	
	; LXRSH@
	cmp    cl,10h
	jnb    LSR_13
	mov    bx,dx
	shr    ax,cl
	sar    dx,cl
	neg    cl
	add    cl,10h
	shl    bx,cl
	or     ax,bx
	pop    cx
	pop    bp
	retf
LSR_13:
	sub    cl,10h
	xchg   dx,ax
	cwd
	sar    ax,cl
	pop    cx
	pop    bp
	retf
SR_ulshr:	; N_LXURSH@
	; r = a >> b
	pop    bx
	push   cs
	push   bx

	push   bp
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx

        mov    ax, [bp+6]	; pop loword(a)
	mov    dx, [bp+8]	; pop hiword(a)
	mov    cx, [bp+10]	; pop word(b)
	
	; LXURSH@
	cmp    cl,10h
	jnb    LSR_14
	mov    bx,dx
	shr    ax,cl
	shr    dx,cl
	neg    cl
	add    cl,10h
	shl    bx,cl
	or     ax,bx
	pop    cx
	pop    bp
	retf
LSR_14:
	sub    cl,10h
	xchg   dx,ax
	xor    dx,dx
	shr    ax,cl
	pop    cx
	pop    bp
	retf
SR_lmul:	; N_LXMUL@
SR_ulmul:
	; r = a * b
	push   bp
	push   si
	mov    bp,sp

	push   cx	; C86 doesn't expect use of cx or bx
	push   bx

        mov    bx, [bp+6]	; pop loword(a)
	mov    cx, [bp+8]	; pop hiword(a)
	mov    ax, [bp+10]	; pop loword(b)
	mov    dx, [bp+12]	; pop hiword(b)
	
	xchg   si,ax
	xchg   dx,ax
	test   ax,ax
	je     LSR_15
	mul    bx
LSR_15:
	jcxz   LSR_16
	xchg   cx,ax
	mul    si
	add    ax,cx
LSR_16:
	xchg   si,ax
	mul    bx
	add    dx,si
	pop    bx
	pop    cx
	pop    si
	pop    bp
	ret

; Generated by c86 (BYU-NASM) 5.1 (beta) from clib.c
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
new_line:
	db	13,10,36
	ALIGN	2
signalEOI:
	jmp	L_clib_1
L_clib_2:
	mov	al, 0x20
	out	0x20, al
	mov	sp, bp
	pop	bp
	ret
L_clib_1:
	push	bp
	mov	bp, sp
	jmp	L_clib_2
	ALIGN	2
exit:
	jmp	L_clib_4
L_clib_5:
	mov	ah, 4Ch
	mov	al, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_4:
	push	bp
	mov	bp, sp
	jmp	L_clib_5
	ALIGN	2
print:
	jmp	L_clib_7
L_clib_8:
	mov	ah, 40h
	mov	bx, 1
	mov	cx, [bp+6]
	mov	dx, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_7:
	push	bp
	mov	bp, sp
	jmp	L_clib_8
	ALIGN	2
printChar:
	jmp	L_clib_10
L_clib_11:
	mov	ah, 2
	mov	dl, [bp+4]
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_10:
	push	bp
	mov	bp, sp
	jmp	L_clib_11
	ALIGN	2
printNewLine:
	jmp	L_clib_13
L_clib_14:
	mov	ah, 9
	mov	dx, new_line
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_13:
	push	bp
	mov	bp, sp
	jmp	L_clib_14
	ALIGN	2
printString:
	jmp	L_clib_16
L_clib_17:
	xor	si,si
	mov	bx, [bp+4]
	jmp	printString2
	printString1:
	inc	si
	printString2:
	cmp	byte [bx+si],0
	jne	printString1
	mov	dx, bx
	mov	cx, si
	mov	ah, 40h
	mov	bx, 1
	int	21h
	mov	sp, bp
	pop	bp
	ret
L_clib_16:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_clib_17
	ALIGN	2
printInt:
	jmp	L_clib_19
L_clib_20:
	mov	word [bp-2], 0
	mov	word [bp-4], 10000
	cmp	word [bp+4], 0
	jge	L_clib_21
	mov	byte [bp-10], 45
	inc	word [bp-2]
	mov	ax, word [bp+4]
	neg	ax
	mov	word [bp+4], ax
L_clib_21:
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_clib_22
	mov	word [bp-4], 1
	jmp	L_clib_23
L_clib_22:
	jmp	L_clib_25
L_clib_24:
	mov	ax, word [bp-4]
	cwd
	mov	cx, 10
	idiv	cx
	mov	word [bp-4], ax
L_clib_25:
	mov	ax, word [bp+4]
	cwd
	idiv	word [bp-4]
	test	ax, ax
	je	L_clib_24
L_clib_26:
L_clib_23:
	jmp	L_clib_28
L_clib_27:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-10]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	mov	ax, dx
	mov	word [bp+4], ax
	mov	ax, word [bp-4]
	cwd
	mov	cx, 10
	idiv	cx
	mov	word [bp-4], ax
	mov	ax, word [bp-4]
	mov	word [bp-4], ax
L_clib_28:
	cmp	word [bp-4], 0
	jg	L_clib_27
L_clib_29:
	push	word [bp-2]
	lea	ax, [bp-10]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_19:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_clib_20
	ALIGN	2
printLong:
	jmp	L_clib_31
L_clib_32:
	mov	word [bp-2], 0
	mov	word [bp-6], 51712
	mov	word [bp-4], 15258
	cmp	word [bp+6], 0
	jg	L_clib_33
	jl	L_clib_34
	cmp	word [bp+4], 0
	jae	L_clib_33
L_clib_34:
	mov	byte [bp-17], 45
	inc	word [bp-2]
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	neg	ax
	adc	dx, 0
	neg	dx
	mov	word [bp+4], ax
	mov	word [bp+6], dx
L_clib_33:
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	or	dx, ax
	jne	L_clib_35
	mov	word [bp-6], 1
	mov	word [bp-4], 0
	jmp	L_clib_36
L_clib_35:
	jmp	L_clib_38
L_clib_37:
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asldiv
L_clib_38:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_ldiv
	or	dx, ax
	je	L_clib_37
L_clib_39:
L_clib_36:
	jmp	L_clib_41
L_clib_40:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-17]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_lmod
	mov	word [bp+4], ax
	mov	word [bp+6], dx
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asldiv
L_clib_41:
	cmp	word [bp-4], 0
	jg	L_clib_40
	jne	L_clib_43
	cmp	word [bp-6], 0
	ja	L_clib_40
L_clib_43:
L_clib_42:
	push	word [bp-2]
	lea	ax, [bp-17]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_31:
	push	bp
	mov	bp, sp
	sub	sp, 18
	jmp	L_clib_32
	ALIGN	2
printUInt:
	jmp	L_clib_45
L_clib_46:
	mov	word [bp-2], 0
	mov	word [bp-4], 10000
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_clib_47
	mov	word [bp-4], 1
	jmp	L_clib_48
L_clib_47:
	jmp	L_clib_50
L_clib_49:
	mov	ax, word [bp-4]
	xor	dx, dx
	mov	cx, 10
	div	cx
	mov	word [bp-4], ax
L_clib_50:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	test	ax, ax
	je	L_clib_49
L_clib_51:
L_clib_48:
	jmp	L_clib_53
L_clib_52:
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-10]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	mov	ax, word [bp+4]
	xor	dx, dx
	div	word [bp-4]
	mov	word [bp+4], dx
	mov	ax, word [bp-4]
	xor	dx, dx
	mov	cx, 10
	div	cx
	mov	word [bp-4], ax
L_clib_53:
	mov	ax, word [bp-4]
	test	ax, ax
	jne	L_clib_52
L_clib_54:
	push	word [bp-2]
	lea	ax, [bp-10]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_45:
	push	bp
	mov	bp, sp
	sub	sp, 10
	jmp	L_clib_46
	ALIGN	2
printULong:
	jmp	L_clib_56
L_clib_57:
	mov	word [bp-2], 0
	mov	word [bp-6], 51712
	mov	word [bp-4], 15258
	mov	ax, word [bp+4]
	mov	dx, word [bp+6]
	or	dx, ax
	jne	L_clib_58
	mov	word [bp-6], 1
	mov	word [bp-4], 0
	jmp	L_clib_59
L_clib_58:
	jmp	L_clib_61
L_clib_60:
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asuldiv
L_clib_61:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	or	dx, ax
	je	L_clib_60
L_clib_62:
L_clib_59:
	jmp	L_clib_64
L_clib_63:
	push	word [bp-4]
	push	word [bp-6]
	push	word [bp+6]
	push	word [bp+4]
	call	SR_uldiv
	add	al, 48
	mov	si, word [bp-2]
	lea	dx, [bp-17]
	add	si, dx
	mov	byte [si], al
	inc	word [bp-2]
	push	word [bp-4]
	push	word [bp-6]
	lea	ax, [bp+4]
	push	ax
	call	SR_asilmod
	mov	ax, 10
	xor	dx, dx
	push	dx
	push	ax
	lea	ax, [bp-6]
	push	ax
	call	SR_asuldiv
L_clib_64:
	mov	ax, word [bp-6]
	mov	dx, word [bp-4]
	or	dx, ax
	jne	L_clib_63
L_clib_65:
	push	word [bp-2]
	lea	ax, [bp-17]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_56:
	push	bp
	mov	bp, sp
	sub	sp, 18
	jmp	L_clib_57
	ALIGN	2
printByte:
	jmp	L_clib_67
L_clib_68:
	mov	al, byte [bp+4]
	cbw
	mov	cx, 4
	sar	ax, cl
	and	ax, 15
	mov	byte [bp-1], al
	cmp	byte [bp-1], 9
	jle	L_clib_69
	mov	al, byte [bp-1]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_70
L_clib_69:
	mov	al, byte [bp-1]
	cbw
	add	ax, 48
L_clib_70:
	mov	byte [bp-3], al
	mov	al, byte [bp+4]
	and	al, 15
	mov	byte [bp-1], al
	cmp	byte [bp-1], 9
	jle	L_clib_71
	mov	al, byte [bp-1]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_72
L_clib_71:
	mov	al, byte [bp-1]
	cbw
	add	ax, 48
L_clib_72:
	mov	byte [bp-2], al
	mov	ax, 2
	push	ax
	lea	ax, [bp-3]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_67:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_clib_68
	ALIGN	2
printWord:
	jmp	L_clib_74
L_clib_75:
	mov	word [bp-2], 3
	jmp	L_clib_77
L_clib_76:
	mov	ax, word [bp+4]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_80
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_81
L_clib_80:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_81:
	mov	si, word [bp-2]
	lea	dx, [bp-7]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp+4]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp+4], ax
L_clib_79:
	dec	word [bp-2]
L_clib_77:
	cmp	word [bp-2], 0
	jge	L_clib_76
L_clib_78:
	mov	ax, 4
	push	ax
	lea	ax, [bp-7]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_74:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_clib_75
	ALIGN	2
printDWord:
	jmp	L_clib_83
L_clib_84:
	lea	ax, [bp+4]
	mov	si, ax
	mov	ax, word [si]
	mov	word [bp-6], ax
	lea	ax, [bp+4]
	mov	si, ax
	add	si, 2
	mov	ax, word [si]
	mov	word [bp-8], ax
	mov	word [bp-2], 3
	jmp	L_clib_86
L_clib_85:
	mov	ax, word [bp-6]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_89
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_90
L_clib_89:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_90:
	mov	dx, word [bp-2]
	add	dx, 4
	mov	si, dx
	lea	dx, [bp-16]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp-6]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp-6], ax
	mov	ax, word [bp-8]
	and	ax, 15
	mov	byte [bp-3], al
	cmp	byte [bp-3], 9
	jle	L_clib_91
	mov	al, byte [bp-3]
	cbw
	sub	ax, 10
	add	ax, 65
	jmp	L_clib_92
L_clib_91:
	mov	al, byte [bp-3]
	cbw
	add	ax, 48
L_clib_92:
	mov	si, word [bp-2]
	lea	dx, [bp-16]
	add	si, dx
	mov	byte [si], al
	mov	ax, word [bp-8]
	mov	cx, 4
	sar	ax, cl
	mov	word [bp-8], ax
L_clib_88:
	dec	word [bp-2]
L_clib_86:
	cmp	word [bp-2], 0
	jge	L_clib_85
L_clib_87:
	mov	ax, 8
	push	ax
	lea	ax, [bp-16]
	push	ax
	call	print
	add	sp, 4
	mov	sp, bp
	pop	bp
	ret
L_clib_83:
	push	bp
	mov	bp, sp
	sub	sp, 16
	jmp	L_clib_84
; ISR file
;1 Save the context of whatever was running by pushing all registers onto the stack, except SP, SS, CS, IP, and the flags.
;2 Enable interrupts to allow higher priority IRQs to interrupt.
;3 Run the interrupt handler, which is usually a C function that does the work for this interrupt.
;4 Disable interrupts.
;5 Send the EOI command to the PIC, informing it that the handler is finished.
;6 Restore the context of what was running before the interrupt occurred by popping the registers saved in step 1 off the stack.
;7 Execute the iret instruction. This restores in one atomic operation the values for IP, CS, and the flags, which were automatically -
;	; - saved on the stack by the processor when the interrupt occurred. This effectively restores execution to the point where the interrupt occurred.


RESET:
	push ax	
	push bx	
	push cx	
	push dx	
	push bp	
	push si	
	push di	
	push ds	
	push es
	
	call YKEnterISR
	sti
	call c_reset_handler
	cli
	mov	al, 0x20
	out 	0x20, al
	
	;pop word[bp+20]
	call YKExitISR ; TODO: not sure if this should be called before or after the next instruction
	
	pop es	
	pop ds	
	pop di	
	pop si	
	pop bp	
	pop dx	
	pop cx	
	pop bx	
	pop ax
	
	iret
	

KEY:

	push ax	
	push bx	
	push cx	
	push dx	
	push bp	
	push si	
	push di	
	push ds	
	push es
	
	; Inform OS that ISR has begun execution
	call YKEnterISR

	; enable interrupts for higher priority IRQs ? 
	sti
	
	; run inte
	call c_key_handler
	
	; disable interrupts ?
	cli
	
	; send eoi to pic
	mov al, 0x20
	out 0x20, al
	
	; Inform OS that ISR has finished execution
	
	
	call YKExitISR

	;restore reg
	pop es	
	pop ds	
	pop di	
	pop si	
	pop bp	
	pop dx	
	pop cx	
	pop bx	
	pop ax

	iret 

TICK:
	; save reg
	push ax	
	push bx	
	push cx	
	push dx	
	push bp	
	push si	
	push di	
	push ds	
	push es
	
	mov bx, [YKRdyList]
	mov [bx], sp
	
	; Inform OS that ISR has started execution
	call YKEnterISR

	; enable interrupts for higher priority IRQs ? 
	sti
	
	; run interrupt handler ? I think this is the c file
	call c_tick_handler
	
	; disable interrupts ?
	cli
	
	; send eoi to pic
	mov al, 0x20
	out 0x20, al
	
	; Inform OS that ISR has finished execution
	call YKExitISR

	;restore reg
	pop es	
	pop ds	
	pop di	
	pop si	
	pop bp	
	pop dx	
	pop cx	
	pop bx	
	pop ax
	
	; execute iret
	iret 
; Generated by c86 (BYU-NASM) 5.1 (beta) from myinth.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
L_myinth_1:
	DB	0xA,"RESET PROGRAM",0xA,0
	ALIGN	2
c_reset_handler:
	; >>>>> Line:	11
	; >>>>> void c_reset_handler(){ 
	jmp	L_myinth_2
L_myinth_3:
	; >>>>> Line:	12
	; >>>>> printString("\nRESET PROGRAM\n"); 
	mov	ax, L_myinth_1
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	13
	; >>>>> exit(0); 
	xor	al, al
	push	ax
	call	exit
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_myinth_2:
	push	bp
	mov	bp, sp
	jmp	L_myinth_3
	ALIGN	2
L_myinth_5:
	DW	1
L_myinth_6:
	DB	0xA,"TICK ",0
	ALIGN	2
c_tick_handler:
	; >>>>> Line:	17
	; >>>>> void c_tick_handler(){ 
	jmp	L_myinth_7
L_myinth_8:
	; >>>>> Line:	19
	; >>>>> printString("\nTICK "); 
	mov	ax, L_myinth_6
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	20
	; >>>>> printInt(tick++); 
	mov	ax, word [L_myinth_5]
	inc	word [L_myinth_5]
	push	ax
	call	printInt
	add	sp, 2
	; >>>>> Line:	21
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	23
	; >>>>> YKTickHandler(); 
	call	YKTickHandler
	mov	sp, bp
	pop	bp
	ret
L_myinth_7:
	push	bp
	mov	bp, sp
	jmp	L_myinth_8
L_myinth_13:
	DB	") IGNORED*********************************************",0xD,0xA,0
L_myinth_12:
	DB	0xD,0xA,"KEYPRESS (",0
L_myinth_11:
	DB	0xD,0xA,"DELAY COMPLETE$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$",0xD,0xA,0
L_myinth_10:
	DB	0xD,0xA,"DELAY KEY PRESSED",0xD,0xA,0
	ALIGN	2
c_key_handler:
	; >>>>> Line:	26
	; >>>>> void c_key_handler(){ 
	jmp	L_myinth_14
L_myinth_15:
	; >>>>> Line:	29
	; >>>>> if (c == 'd'){ 
	mov	word [bp-2], 0
	mov	al, byte [KeyBuffer]
	mov	byte [bp-3], al
	; >>>>> Line:	29
	; >>>>> if (c == 'd'){ 
	cmp	byte [bp-3], 100
	jne	L_myinth_16
	; >>>>> Line:	30
	; >>>>> printString("\r\nDELAY KEY PRESSED\r\n"); 
	mov	ax, L_myinth_10
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	32
	; >>>>> for(i = 0; i < 5000; i=i){ 
	mov	word [bp-2], 0
	jmp	L_myinth_18
L_myinth_17:
	; >>>>> Line:	33
	; >>>>> i++; 
	inc	word [bp-2]
L_myinth_20:
	mov	ax, word [bp-2]
	mov	word [bp-2], ax
L_myinth_18:
	cmp	word [bp-2], 5000
	jl	L_myinth_17
L_myinth_19:
	; >>>>> Line:	35
	; >>>>> printString("\r\nDELAY COMPLETE$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$\r\n"); 
	mov	ax, L_myinth_11
	push	ax
	call	printString
	add	sp, 2
	jmp	L_myinth_21
L_myinth_16:
	; >>>>> Line:	38
	; >>>>> printString("\r\nKEYPRESS ("); 
	mov	ax, L_myinth_12
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	39
	; >>>>> printChar(c); 
	push	word [bp-3]
	call	printChar
	add	sp, 2
	; >>>>> Line:	40
	; >>>>>  
	mov	ax, L_myinth_13
	push	ax
	call	printString
	add	sp, 2
L_myinth_21:
	mov	sp, bp
	pop	bp
	ret
L_myinth_14:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_myinth_15
	ALIGN	2
delay:
	; >>>>> Line:	44
	; >>>>> void delay(){ 
	jmp	L_myinth_23
L_myinth_24:
	; >>>>> Line:	46
	; >>>>> for(i = 0; i < 5000; i++){} 
	mov	word [bp-2], 0
	; >>>>> Line:	46
	; >>>>> for(i = 0; i < 5000; i++){} 
	mov	word [bp-2], 0
	jmp	L_myinth_26
L_myinth_25:
L_myinth_28:
	; >>>>> Line:	46
	; >>>>> for(i = 0; i < 5000; i++){} 
	inc	word [bp-2]
L_myinth_26:
	cmp	word [bp-2], 5000
	jl	L_myinth_25
L_myinth_27:
	mov	sp, bp
	pop	bp
	ret
L_myinth_23:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_myinth_24
L_myinth_30:
	DB	0xD,0xA,"DEBUGGER",0xD,0xA,0
	ALIGN	2
print_debug:
	; >>>>> Line:	49
	; >>>>> void print_debug(){ 
	jmp	L_myinth_31
L_myinth_32:
	; >>>>> Line:	50
	; >>>>> printString("\r\nDEBUGGER\r\n"); 
	mov	ax, L_myinth_30
	push	ax
	call	printString
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_myinth_31:
	push	bp
	mov	bp, sp
	jmp	L_myinth_32
; Generated by c86 (BYU-NASM) 5.1 (beta) from yakc.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
run_flag:
	DB	0
	ALIGN	2
YKInitialize:
	; >>>>> Line:	25
	; >>>>> void YKInitialize(void){ 
	jmp	L_yakc_1
L_yakc_2:
	; >>>>> Line:	27
	; >>>>> YKCtxSwCount = 0; 
	mov	word [YKCtxSwCount], 0
	; >>>>> Line:	28
	; >>>>> YKIdleCount = 0; 
	mov	word [YKIdleCount], 0
	; >>>>> Line:	29
	; >>>>> TKCurrentlyRunning = 0; 
	mov	word [TKCurrentlyRunning], 0
	; >>>>> Line:	34
	; >>>>> YKAvailTCBList = &(YKTCBArray[0]); 
	mov	word [YKAvailTCBList], YKTCBArray
	; >>>>> Line:	36
	; >>>>> for (i = 0; i < 3; i++) 
	mov	word [bp-2], 0
	jmp	L_yakc_4
L_yakc_3:
	; >>>>> Line:	37
	; >>>>> YKTCBArray[i].next = &(YKTCBArray[i+1]); 
	mov	ax, word [bp-2]
	inc	ax
	mov	cx, 14
	imul	cx
	add	ax, YKTCBArray
	push	ax
	mov	ax, word [bp-2]
	mov	cx, 14
	imul	cx
	mov	dx, ax
	add	dx, YKTCBArray
	mov	si, dx
	add	si, 10
	pop	ax
	mov	word [si], ax
L_yakc_6:
	inc	word [bp-2]
L_yakc_4:
	cmp	word [bp-2], 3
	jl	L_yakc_3
L_yakc_5:
	; >>>>> Line:	38
	; >>>>> YKTCBArray[3].next = 0; 
	mov	word [(52+YKTCBArray)], 0
	; >>>>> Line:	40
	; >>>>> YKNewTask(YKIdleTask, (void*)&idleStack[256], 100); 
	mov	al, 100
	push	ax
	mov	ax, (idleStack+512)
	push	ax
	mov	ax, YKIdleTask
	push	ax
	call	YKNewTask
	add	sp, 6
	mov	sp, bp
	pop	bp
	ret
L_yakc_1:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_2
	ALIGN	2
YKIdleTask:
	; >>>>> Line:	47
	; >>>>> void YKIdleTask(void){ 
	jmp	L_yakc_8
L_yakc_9:
	; >>>>> Line:	48
	; >>>>> while(1){ 
	jmp	L_yakc_11
L_yakc_10:
	; >>>>> Line:	49
	; >>>>> YKIdleCount=YKIdleCount+1; 
	mov	ax, word [YKIdleCount]
	inc	ax
	mov	word [YKIdleCount], ax
	; >>>>> Line:	50
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_11:
	jmp	L_yakc_10
L_yakc_12:
	mov	sp, bp
	pop	bp
	ret
L_yakc_8:
	push	bp
	mov	bp, sp
	jmp	L_yakc_9
	ALIGN	2
YKNewTask:
	; >>>>> Line:	54
	; >>>>> void YKNewTask( void (*task)(void), void *taskStack, unsigned char priority){ 
	jmp	L_yakc_14
L_yakc_15:
	; >>>>> Line:	58
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	61
	; >>>>> tmp = YKAvailTCBList; 
	mov	ax, word [YKAvailTCBList]
	mov	word [bp-2], ax
	; >>>>> Line:	62
	; >>>>> YKAvailTCBList = tmp->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKAvailTCBList], ax
	; >>>>> Line:	65
	; >>>>> tmp->priority = priority; 
	mov	al, byte [bp+8]
	xor	ah, ah
	mov	si, word [bp-2]
	add	si, 6
	mov	word [si], ax
	; >>>>> Line:	66
	; >>>>> tmp->delay = 0; 
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	69
	; >>>>> if (YKRdyList == 0){ 
	mov	ax, word [YKRdyList]
	test	ax, ax
	jne	L_yakc_16
	; >>>>> Line:	70
	; >>>>> YKRdyList = tmp; 
	mov	ax, word [bp-2]
	mov	word [YKRdyList], ax
	; >>>>> Line:	71
	; >>>>> tmp->next = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	72
	; >>>>> tmp->prev = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	jmp	L_yakc_17
L_yakc_16:
	; >>>>> Line:	75
	; >>>>> tmp2 = YKRdyList; 
	mov	ax, word [YKRdyList]
	mov	word [bp-4], ax
	; >>>>> Line:	76
	; >>>>> while (tmp2->priority < tmp->priority){ 
	jmp	L_yakc_19
L_yakc_18:
	; >>>>> Line:	77
	; >>>>> tmp2 = tmp2->next; 
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-4], ax
L_yakc_19:
	mov	si, word [bp-4]
	add	si, 6
	mov	di, word [bp-2]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jg	L_yakc_18
L_yakc_20:
	; >>>>> Line:	79
	; >>>>> if (tmp2->prev == 0) 
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_21
	; >>>>> Line:	80
	; >>>>> YKRdyList = tmp; 
	mov	ax, word [bp-2]
	mov	word [YKRdyList], ax
	jmp	L_yakc_22
L_yakc_21:
	; >>>>> Line:	82
	; >>>>> tmp2->prev->next = tmp; 
	mov	si, word [bp-4]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_22:
	; >>>>> Line:	83
	; >>>>> tmp->prev = tmp2->prev; 
	mov	si, word [bp-4]
	add	si, 12
	mov	di, word [bp-2]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	84
	; >>>>> tmp->next = tmp2; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp-4]
	mov	word [si], ax
	; >>>>> Line:	85
	; >>>>> tmp2->prev = tmp; 
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_17:
	; >>>>> Line:	89
	; >>>>> tmp->stackptr = taskStack; 
	mov	si, word [bp-2]
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	90
	; >>>>> tmp->ss = 0; 
	mov	si, word [bp-2]
	add	si, 2
	mov	word [si], 0
	; >>>>> Line:	93
	; >>>>> tmp->stackptr = tmp->stackptr - 11; 
	mov	si, word [bp-2]
	mov	ax, word [si]
	sub	ax, 22
	mov	word [si], ax
	; >>>>> Line:	94
	; >>>>> *(tmp->stackptr+11) = 0x200; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 22
	mov	word [si], 512
	; >>>>> Line:	95
	; >>>>> *(tmp->stackptr+10) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 20
	mov	word [si], 0
	; >>>>> Line:	96
	; >>>>> *(tmp->stackptr+9) = (int)task; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 18
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	97
	; >>>>> *(tmp->stackptr+8) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 16
	mov	word [si], 0
	; >>>>> Line:	98
	; >>>>> *(tmp->stackptr+7) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 14
	mov	word [si], 0
	; >>>>> Line:	99
	; >>>>> *(tmp->stackptr+6) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	100
	; >>>>> *(tmp->stackptr+5) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	101
	; >>>>> *(tmp->stackptr+4) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	102
	; >>>>> *(tmp->stackptr+3) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 6
	mov	word [si], 0
	; >>>>> Line:	103
	; >>>>> *(tmp->stack 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 4
	mov	word [si], 0
	; >>>>> Line:	104
	; >>>>> *(tmp->stackptr+1) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	add	si, 2
	mov	word [si], 0
	; >>>>> Line:	105
	; >>>>> *(tmp->stackptr+0) = 0; 
	mov	si, word [bp-2]
	mov	si, word [si]
	mov	word [si], 0
	; >>>>> Line:	107
	; >>>>> YKScheduler(1); 
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	; >>>>> Line:	108
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_14:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_yakc_15
	ALIGN	2
YKRun:
	; >>>>> Line:	111
	; >>>>> void YKRun(void){ 
	jmp	L_yakc_24
L_yakc_25:
	; >>>>> Line:	112
	; >>>>> run_flag = 1; 
	mov	byte [run_flag], 1
	; >>>>> Line:	113
	; >>>>> YKScheduler(0); 
	xor	ax, ax
	push	ax
	call	YKScheduler
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_yakc_24:
	push	bp
	mov	bp, sp
	jmp	L_yakc_25
L_yakc_32:
	DB	"EXIT SAVE DISPATCHER",0xA,0xD,0
L_yakc_31:
	DB	"EXIT NONSAVE DISPATCHER",0xA,0xD,0
L_yakc_30:
	DB	"NONSAVE",0xA,0xD,0
L_yakc_29:
	DB	" ",0
L_yakc_28:
	DB	"Comp ",0
L_yakc_27:
	DB	"Entering Scheduler",0xA,0xD,0
	ALIGN	2
YKScheduler:
	; >>>>> Line:	116
	; >>>>> void YKScheduler(int save_flag){ 
	jmp	L_yakc_33
L_yakc_34:
	; >>>>> Line:	122
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	123
	; >>>>> printString("Entering Scheduler\n\r"); 
	mov	ax, L_yakc_27
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	124
	; >>>>> highest_priority_task = YKRdyList; 
	mov	ax, word [YKRdyList]
	mov	word [bp-6], ax
	; >>>>> Line:	125
	; >>>>> currentlyRunning = TKCurrentlyRunning; 
	mov	ax, word [TKCurrentlyRunning]
	mov	word [bp-8], ax
	; >>>>> Line:	127
	; >>>>> printString("Comp "); 
	mov	ax, L_yakc_28
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	128
	; >>>>> printInt(TKCurrentlyRunning->priority); 
	mov	si, word [TKCurrentlyRunning]
	add	si, 6
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	129
	; >>>>> printString(" "); 
	mov	ax, L_yakc_29
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	130
	; >>>>> Running 
	mov	si, word [bp-6]
	add	si, 6
	push	word [si]
	call	printInt
	add	sp, 2
	; >>>>> Line:	131
	; >>>>> printNewLine(); 
	call	printNewLine
	; >>>>> Line:	133
	; >>>>> if(!run_flag || (TKCurrentlyRunning == highest_priority_task)){ 
	mov	al, byte [run_flag]
	test	al, al
	je	L_yakc_36
	mov	ax, word [bp-6]
	cmp	ax, word [TKCurrentlyRunning]
	jne	L_yakc_35
L_yakc_36:
	; >>>>> Line:	134
	; >>>>> return; 
	jmp	L_yakc_37
L_yakc_35:
	; >>>>> Line:	137
	; >>>>> YKCtxSwCount = YKCtxSwCount + 1; 
	mov	ax, word [YKCtxSwCount]
	inc	ax
	mov	word [YKCtxSwCount], ax
	; >>>>> Line:	138
	; >>>>> TKCurrentlyRunning = highest_priority_task; 
	mov	ax, word [bp-6]
	mov	word [TKCurrentlyRunning], ax
	; >>>>> Line:	139
	; >>>>> if(!save_flag){ 
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_yakc_38
	; >>>>> Line:	140
	; >>>>> printString("NONSAVE\n\r"); 
	mov	ax, L_yakc_30
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	141
	; >>>>> YKDispatcherNSave(highest_priority_task->stackptr, highest_priority_task->ss); 
	mov	si, word [bp-6]
	add	si, 2
	push	word [si]
	mov	si, word [bp-6]
	push	word [si]
	call	YKDispatcherNSave
	add	sp, 4
	; >>>>> Line:	142
	; >>>>> printString("EXIT NONSAVE DISPATCHER\n\r"); 
	mov	ax, L_yakc_31
	push	ax
	call	printString
	add	sp, 2
	jmp	L_yakc_39
L_yakc_38:
	; >>>>> Line:	145
	; >>>>> printString("SAVE\n\r"); 
	mov	ax, (L_yakc_30+3)
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	146
	; >>>>> YKDispatcherSave(&(currentlyRunning->stackptr),&(currentlyRunning 
	mov	si, word [bp-6]
	add	si, 2
	push	word [si]
	mov	si, word [bp-6]
	push	word [si]
	mov	ax, word [bp-8]
	add	ax, 2
	push	ax
	push	word [bp-8]
	call	YKDispatcherSave
	add	sp, 8
	; >>>>> Line:	148
	; >>>>> printString("EXIT SAVE DISPATCHER\n\r"); 
	mov	ax, L_yakc_32
	push	ax
	call	printString
	add	sp, 2
L_yakc_39:
	; >>>>> Line:	150
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_37:
	mov	sp, bp
	pop	bp
	ret
L_yakc_33:
	push	bp
	mov	bp, sp
	sub	sp, 8
	jmp	L_yakc_34
	ALIGN	2
YKDelayTask:
	; >>>>> Line:	161
	; >>>>> void YKDelayTask(unsigned count){ 
	jmp	L_yakc_41
L_yakc_42:
	; >>>>> Line:	163
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	165
	; >>>>> if(count == 0){ 
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_yakc_43
	; >>>>> Line:	166
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	167
	; >>>>> return; 
	jmp	L_yakc_44
L_yakc_43:
	; >>>>> Line:	171
	; >>>>> ready = YKRdyList; 
	mov	ax, word [YKRdyList]
	mov	word [bp-2], ax
	; >>>>> Line:	173
	; >>>>> YKRdyList = ready->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKRdyList], ax
	; >>>>> Line:	174
	; >>>>> ready->next->prev = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	176
	; >>>>> ready->next = YKDelayList; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [YKDelayList]
	mov	word [si], ax
	; >>>>> Line:	177
	; >>>>> YKDelayList = ready; 
	mov	ax, word [bp-2]
	mov	word [YKDelayList], ax
	; >>>>> Line:	178
	; >>>>> ready->prev = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	179
	; >>>>> if(ready->next != 0){ 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_45
	; >>>>> Line:	180
	; >>>>> ready->next->prev=ready; 
	mov	si, word [bp-2]
	add	si, 10
	mov	si, word [si]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_45:
	; >>>>> Line:	182
	; >>>>> ready->delay = count; 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	183
	; >>>>> Y 
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	; >>>>> Line:	184
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_44:
	mov	sp, bp
	pop	bp
	ret
L_yakc_41:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_42
	ALIGN	2
YKEnterISR:
	; >>>>> Line:	187
	; >>>>> void YKEnterISR(void){ 
	jmp	L_yakc_47
L_yakc_48:
	; >>>>> Line:	188
	; >>>>> YKISRDepth = YKISRDepth + 1; 
	mov	ax, word [YKISRDepth]
	inc	ax
	mov	word [YKISRDepth], ax
	mov	sp, bp
	pop	bp
	ret
L_yakc_47:
	push	bp
	mov	bp, sp
	jmp	L_yakc_48
	ALIGN	2
YKExitISR:
	; >>>>> Line:	192
	; >>>>> void YKExitISR(void){ 
	jmp	L_yakc_50
L_yakc_51:
	; >>>>> Line:	193
	; >>>>> YKISRDepth = YKISRDepth - 1; 
	mov	ax, word [YKISRDepth]
	dec	ax
	mov	word [YKISRDepth], ax
	; >>>>> Line:	195
	; >>>>> printInt(YKISRDepth); 
	push	word [YKISRDepth]
	call	printInt
	add	sp, 2
	; >>>>> Line:	197
	; >>>>> if(YKISRDepth == 0) { 
	mov	ax, word [YKISRDepth]
	test	ax, ax
	jne	L_yakc_52
	; >>>>> Line:	198
	; >>>>> YKScheduler(1); 
	mov	ax, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_52:
	mov	sp, bp
	pop	bp
	ret
L_yakc_50:
	push	bp
	mov	bp, sp
	jmp	L_yakc_51
	ALIGN	2
YKTickHandler:
	; >>>>> Line:	209
	; >>>>> void YKTickHandler(void){ 
	jmp	L_yakc_54
L_yakc_55:
	; >>>>> Line:	212
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	213
	; >>>>> YKTickNum = YKTickNum + 1; 
	mov	ax, word [YKTickNum]
	inc	ax
	mov	word [YKTickNum], ax
	; >>>>> Line:	214
	; >>>>> tempDelay = YKDelayList; 
	mov	ax, word [YKDelayList]
	mov	word [bp-2], ax
	; >>>>> Line:	216
	; >>>>> while(tempDelay != 0){ 
	jmp	L_yakc_57
L_yakc_56:
	; >>>>> Line:	217
	; >>>>> tempNext = tempDelay->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-6], ax
	; >>>>> Line:	218
	; >>>>> tempDelay->delay = tempDelay->delay - 1; 
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [si]
	dec	ax
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], ax
	; >>>>> Line:	219
	; >>>>> if(tempDelay->delay <= 0){ 
	mov	si, word [bp-2]
	add	si, 8
	cmp	word [si], 0
	jg	L_yakc_59
	; >>>>> Line:	221
	; >>>>> if(tempDelay->prev == 0){ 
	mov	si, word [bp-2]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_60
	; >>>>> Line:	222
	; >>>>> YKDelayList = tempDelay->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	mov	word [YKDelayList], ax
	jmp	L_yakc_61
L_yakc_60:
	; >>>>> Line:	225
	; >>>>> tempDelay->prev->next = tempDelay->next; 
	mov	si, word [bp-2]
	add	si, 10
	mov	di, word [bp-2]
	add	di, 12
	mov	di, word [di]
	add	di, 10
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_61:
	; >>>>> Line:	227
	; >>>>> if(tempDelay->next != 0){ 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [si]
	test	ax, ax
	je	L_yakc_62
	; >>>>> Line:	228
	; >>>>> tempDelay->next->prev = tempDelay->prev; 
	mov	si, word [bp-2]
	add	si, 12
	mov	di, word [bp-2]
	add	di, 10
	mov	di, word [di]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_62:
	; >>>>> Line:	231
	; >>>>> tempReady = YKRdyList; 
	mov	ax, word [YKRdyList]
	mov	word [bp-4], ax
	; >>>>> Line:	232
	; >>>>> while(tempReady->priority < tempDelay->priority){ 
	jmp	L_yakc_64
L_yakc_63:
	; >>>>> Line:	233
	; >>>>> tempReady = tempReady->next; 
	mov	si, word [bp-4]
	add	si, 10
	mov	ax, word [si]
	mov	word [bp-4], ax
L_yakc_64:
	mov	si, word [bp-4]
	add	si, 6
	mov	di, word [bp-2]
	add	di, 6
	mov	ax, word [di]
	cmp	ax, word [si]
	jg	L_yakc_63
L_yakc_65:
	; >>>>> Line:	235
	; >>>>> if(tempReady->prev == 0){ 
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_66
	; >>>>> Line:	236
	; >>>>> YKRdyList = tempDelay; 
	mov	ax, word [bp-2]
	mov	word [YKRdyList], ax
	jmp	L_yakc_67
L_yakc_66:
	; >>>>> Line:	239
	; >>>>> tempReady->prev->next = tempDelay; 
	mov	si, word [bp-4]
	add	si, 12
	mov	si, word [si]
	add	si, 10
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_67:
	; >>>>> Line:	242
	; >>>>> te 
	mov	si, word [bp-4]
	add	si, 12
	mov	di, word [bp-2]
	add	di, 12
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	243
	; >>>>> tempDelay->next = tempReady; 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp-4]
	mov	word [si], ax
	; >>>>> Line:	244
	; >>>>> tempReady->prev = tempDelay; 
	mov	si, word [bp-4]
	add	si, 12
	mov	ax, word [bp-2]
	mov	word [si], ax
L_yakc_59:
	; >>>>> Line:	246
	; >>>>> tempDelay = tempNext; 
	mov	ax, word [bp-6]
	mov	word [bp-2], ax
L_yakc_57:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_56
L_yakc_58:
	; >>>>> Line:	248
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_54:
	push	bp
	mov	bp, sp
	sub	sp, 6
	jmp	L_yakc_55
	ALIGN	2
YKCtxSwCount:
	TIMES	2 db 0
YKIdleCount:
	TIMES	2 db 0
YKTickNum:
	TIMES	2 db 0
YKISRDepth:
	TIMES	2 db 0
YKRdyList:
	TIMES	2 db 0
YKDelayList:
	TIMES	2 db 0
YKAvailTCBList:
	TIMES	2 db 0
YKTCBArray:
	TIMES	56 db 0
idleStack:
	TIMES	512 db 0
TKCurrentlyRunning:
	TIMES	2 db 0
;Assemble funtcions

YKEnterMutex:                   ; Disables interrupts 
	cli	                          ; clear interrupt flag
	ret


YKExitMutex:                    ; Enables Interrupts 
	sti	                          ; set interrupt flag 
	ret

YKDispatcherNSave:   		; Dispatcher that saves to mem/stack
	push bp
	mov bp, sp

	; Get the ss and sp values to restore and save them to ss and sp
	mov sp, word[bp+4]			; getting first arg
	mov ss, word[bp+6]			; getting second arg	
	
	; Pop register values off the stack
	pop ES
	pop DS
	pop DI
	pop SI
	pop BP
	pop DX
	pop CX
	pop BX
	pop AX
	iret		

YKDispatcherSave:   		; Dispatcher that saves to mem/stack
	push bp
	mov bp, sp
	
	;push AX
	;mov BX, [bp+2]	; The return address.
	pop bp
	add sp, 2
	
	; Push flags, CS, and IP to the stack
	pushf

	; This is something about the flags that Ian told me to do
	push BX
	add sp, 2
	pop BX
	or BX, 0x200
	push BX
	sub sp, 2
	pop BX
	
	push CS	
	push word[bp+2]
	; Push all register values to the stack
	push AX
	push BX
	push CX
	push DX
	push BP						
	push SI
	push DI
	push DS
	push ES

	; Move bp back to its original value
	mov bp, sp
	add bp, 20
	
	; Store the save sp to si
	mov si, word [bp+4] 			; getting first arg (sp)
	mov word [si], sp

	; Store the save ss to si
	mov si, word [bp+6]			; getting second arg (ss)
	mov word [si], ss

	; Save the sp and ss values to restore to sp and ss
	mov sp, word[bp+8]			; getting third arg
	mov ss, word[bp+10]			; getting fourth arg	

	; Pop register values back off the stack
	pop ES
	pop DS
	pop DI
	pop SI
	pop BP
	pop DX
	pop CX
	pop BX
	pop AX
	iret			
	
; Generated by c86 (BYU-NASM) 5.1 (beta) from lab4c_app.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
L_lab4c_app_2:
	DB	"Starting kernel...",0xA,0
L_lab4c_app_1:
	DB	"Creating task...",0xA,0
	ALIGN	2
main:
	; >>>>> Line:	17
	; >>>>> { 
	jmp	L_lab4c_app_3
L_lab4c_app_4:
	; >>>>> Line:	18
	; >>>>> YKInitialize(); 
	call	YKInitialize
	; >>>>> Line:	20
	; >>>>> printString("Creating task...\n"); 
	mov	ax, L_lab4c_app_1
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	21
	; >>>>> YKNewTask(Task, (void *) &TaskStack[256], 0); 
	xor	al, al
	push	ax
	mov	ax, (TaskStack+512)
	push	ax
	mov	ax, Task
	push	ax
	call	YKNewTask
	add	sp, 6
	; >>>>> Line:	23
	; >>>>> printString("Starting kernel...\n"); 
	mov	ax, L_lab4c_app_2
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	24
	; >>>>> YKRun(); 
	call	YKRun
	mov	sp, bp
	pop	bp
	ret
L_lab4c_app_3:
	push	bp
	mov	bp, sp
	jmp	L_lab4c_app_4
L_lab4c_app_9:
	DB	" context switches! YKIdleCount is ",0
L_lab4c_app_8:
	DB	"Task running after ",0
L_lab4c_app_7:
	DB	"Delaying task...",0xA,0
L_lab4c_app_6:
	DB	"Task started.",0xA,0
	ALIGN	2
Task:
	; >>>>> Line:	28
	; >>>>> { 
	jmp	L_lab4c_app_10
L_lab4c_app_11:
	; >>>>> Line:	32
	; >>>>> printString("Task started.\n"); 
	mov	ax, L_lab4c_app_6
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	33
	; >>>>> while (1) 
	jmp	L_lab4c_app_13
L_lab4c_app_12:
	; >>>>> Line:	35
	; >>>>> printString("Delaying task...\n"); 
	mov	ax, L_lab4c_app_7
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	37
	; >>>>> YKDelayTask(2); 
	mov	ax, 2
	push	ax
	call	YKDelayTask
	add	sp, 2
	; >>>>> Line:	39
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	40
	; >>>>> numCtxSwitches = YKCtxSwCount; 
	mov	ax, word [YKCtxSwCount]
	mov	word [bp-4], ax
	; >>>>> Line:	41
	; >>>>> idleCount = YKIdleCount; 
	mov	ax, word [YKIdleCount]
	mov	word [bp-2], ax
	; >>>>> Line:	42
	; >>>>>  
	mov	word [YKIdleCount], 0
	; >>>>> Line:	43
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	45
	; >>>>> printString("Task running after "); 
	mov	ax, L_lab4c_app_8
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	46
	; >>>>> printUInt(numCtxSwitches); 
	push	word [bp-4]
	call	printUInt
	add	sp, 2
	; >>>>> Line:	47
	; >>>>> printString(" context switches! YKIdleCount is "); 
	mov	ax, L_lab4c_app_9
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	48
	; >>>>> printUInt(idleCount); 
	push	word [bp-2]
	call	printUInt
	add	sp, 2
	; >>>>> Line:	49
	; >>>>> printString(".\n"); 
	mov	ax, (L_lab4c_app_1+15)
	push	ax
	call	printString
	add	sp, 2
L_lab4c_app_13:
	jmp	L_lab4c_app_12
L_lab4c_app_14:
	mov	sp, bp
	pop	bp
	ret
L_lab4c_app_10:
	push	bp
	mov	bp, sp
	sub	sp, 4
	jmp	L_lab4c_app_11
	ALIGN	2
TaskStack:
	TIMES	512 db 0
